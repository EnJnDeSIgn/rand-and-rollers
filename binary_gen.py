import random

def bin2dec(binary):
    return int(binary, 2)

def dec2bin(decimal):
    return bin(decimal)[2:].zfill(30)

# The number of combinations of a binary string of length 10 can be calculated as 
# 2^10. This is because each digit in the binary string can be either 0 or 1. So, 
# 2^10=1024.
# you're absolutely right! The number of subsets of the set {0, 1, 2, ..., 9} and
# the number of binary strings of length 10 are both 1024.
# Quite the neat mathematical connection!
def generate_random_binary():
    groups = [
        "1000000001", "1100100001", "0101111001", "1111101000", "0000110001", "0010001100", "1000000101", "0101110111", "0101100000",   #1-9
        "0100011100", "0011000000", "1111101110", "0001001011", "1110011011", "0101101011", "0001010100", "1101101001", "0001110111",   # 18
        "0000011110", "1011000101", "1000000011", "1001010110", "1010011110", "0111010001", "1000011010", "0110111110", "0011101110",   # 27
        "1011110011", "0110110011", "0011100101", "0101101010", "0001010010", "0010100001", "0000011010", "1100000000", "0110001100",   # 36
        "0110111010", "1011011010", "1101110001", "0111110010", "0100010010", "1011011111", "0011111111", "1101011110", "0100011010",   # 45
        "1001011111", "0000110011", "0100111011", "1011111010", "1011110000", "1000000111", "0100111101", "0100001101", "0111011111",   # 54
        "0010100110", "0100000010", "1100011000", "0111011001", "1101000101", "1000100110", "0011110111", "0000001101", "0010000000",   # 63
        "1000000110", "0111101111", "1111000100", "0000001100", "0110001101", "1010000110", "0001000110", "0100000000", "0101011111",   # 72
        "0110101011", "0011100110", "0010001000", "1010101110", "0001100110", "0101011000", "0010110001", "0111110110", "1001111111",   # 81
        "1000111101", "0011000101", "1111001001", "0011000010", "0011110110", "0111100011", "1111010100", "1100010110", "1000010001",   # 90
        "1110110001", "0010000011", "1011110110", "1001110011", "1101011000", "1011011100", "0100100110", "0100011111", "1110010001",   # 99
        "0011111011", "0111100001", "0000010010", "1010101011", "0101111000", "1101101010", "0101010010", "0010010001", "0011111010",   # 108
        "1111111100", "0100110010", "0101011010", "1111100011", "0111111010", "1011010100", "1111110110", "0100010110", "0100000100",   # 117
        "0100101100", "0111001001", "1111010010", "0110001110", "1111111011", "1101000010", "1011100000", "0001101110", "1011110010",   # 126
        "1001111011", "1101010000", "0001110110", "1101010101", "0001101100", "0011010011", "1110100101", "0001001100", "0110010000",   # 135
        "1101110010", "0000110000", "0111111011", "1010011001", "1101101101", "0110010110", "0000000010", "1000010101", "0010111101",   # 144
        "0011001101", "0010101011", "1101000110", "1011010101", "1010000101", "0010111010", "1110001100", "0100110101", "0100001100",   # 153
        "0100011110", "0101100001", "0100100001", "1100110011", "1000000000", "0100001111", "1110110101", "0011001100", "0110000000",   # 162
        "0001010110", "0001001110", "1010100110", "0101100101", "1100010001", "1001001000", "0000000000", "0001000000", "1000110101",   # 171
        "0111111111", "0110100101", "1001011110", "0111111100", "0000000111", "0100010101", "0010011111", "0000100001", "0100010001",   # 180
        "0000010110", "0010101001", "1001100110", "1101011111", "0110100000", "0101010100", "0110011001", "0010000101", "0001110010",   # 189
        "0110101010", "0100110000", "1100111010", "1010001111", "1111011010", "1110111111", "1101100111", "0110110000", "0110100011",   # 198
        "0110011111", "0110111001", "0000010001", "0000000001", "0000000100", "0110111000", "0110011011", "1111110000", "1100101000",   # 207
        "1001010011", "1110111011", "0101110110", "1100011100", "1000000100", "1100011101", "1110000111", "1001001010", "1001001111",   # 216
        "1111100001", "1110011111", "1111101011", "1100101101", "0011110101", "1111011101", "1110100111", "1011101011", "1110000101",   # 225
        "1000001010", "1111010000", "0000100010", "0011100001", "1110011110", "0000011011", "0001101000", "1010110011", "1111010101",   # 234
        "0011101010", "0001000101", "0010011000", "1111011111", "1111111000", "1010010010", "0100101101", "1111001110", "1110111000",   # 243
        "0000100011", "0001100000", "0100001110", "0011101011", "0000101111", "0100110001", "0011100011", "0100101111", "0001011101",   # 252
        "0111010100", "1101010111", "1001000011", "0110110010", "1001000001", "1110110100", "1001000101", "0001010101", "1100001010",   # 261
        "0010000010", "0111100100", "0011001000", "0011011000", "1100111110", "0101011001", "1101001010", "0101011011", "0100100010",   # 270
        "0011011010", "1111111110", "0100100100", "0001011010", "1011111100", "1000100010", "1111111111", "0111011011", "0100110011",   # 279
        "0101000001", "1011001100", "0011010111", "1100000100", "1011100011", "0000100000", "1100100111", "1011000011", "1011001000",   # 288
        "0010101000", "1001011010", "0000010000", "1110101110", "1110011001", "0010100100", "1011101110", "1011111000", "0010100000",   # 297
        "1000101110", "1001011000", "0011100010", "1110111110", "0111101100", "1010011000", "0100001001", "1011011001", "1001001100",   # 306
        "1011001111", "1000010100", "0111101110", "0111110100", "0011100000", "0001101101", "0010011010", "0010110011", "0110111100",   # 315
        "1110111001", "1011100100", "1101111101", "0100100000", "1001011100", "1011111011", "1001111001", "0011011110", "1110001011",   # 324
        "0010001001", "1000110110", "1000011101", "0001001111", "0110000011", "0101101110", "0101100010", "0111110000", "0110101000",   # 333
        "0011011001", "1000110000", "1000001001", "0001010001", "0110001111", "0011111110", "0011001110", "0010011001", "1010101010",   # 342
        "1101011100", "0111001101", "0010001111", "0010010000", "0010100010", "1101101111", "1000001100", "1100111011", "1001111110",   # 351
        "1011010111", "0001111011", "1110011100", "1101010001", "1000010010", "1011111111", "1000010011", "1010101101", "0011010001",   # 360
        "0100111001", "0111101101", "1001000110", "1011100101", "0101110101", "0110101100", "1111111101", "0001010111", "1010010111",   # 369
        "1111011100", "0011000111", "0111101011", "0100000111", "0010010011", "0000111111", "1010100111", "0111001110", "0111000111",   # 378
        "0111000000", "1100001101", "0010111111", "1101001001", "0001011001", "1111110011", "0111010101", "1111000000", "0010100101",   # 387
        "0110111111", "1101111111", "0001000001", "0001001000", "0110101001", "0000010101", "0010111110", "0010101100", "0000101101",   # 396
        "0111011110", "0011001001", "0001101111", "1011001101", "1101100100", "1010001010", "0111111110", "0011101101", "0000001110",   # 405
        "0000001001", "0011110000", "0101110010", "0011100100", "0100010000", "0101011110", "1111100111", "1111111010", "0100101000",   # 414
        "1011010010", "0100100101", "0110001001", "0101001111", "1011110101", "1100001111", "0000101001", "1100100011", "0110000110",   # 423
        "1001110101", "0101101111", "1111110111", "1110001111", "0100000101", "1011010000", "0001101010", "0100100111", "0010101010",   # 432
        "0000001111", "0111110011", "1101010011", "1101110101", "1101000000", "0000010011", "1000110100", "0111101001", "0101111111",   # 441
        "0001101001", "1101101000", "1111001011", "0101101001", "0010010110", "1000001011", "0110011010", "1011011011", "1010111010",   # 450
        "1100101100", "1111011011", "1111101111", "1010011010", "0100000011", "0001100101", "0111000011", "0101111011", "1111000111",   # 459
        "1010100000", "0101111010", "1010000001", "0001011110", "1111100010", "1011101000", "0011011011", "1000111111", "1100001011",   # 468
        "1111000011", "0111100101", "1000110011", "0101000000", "0011100111", "1011101111", "0110101111", "0111111111", "1110101111",   # 477
        "0101111101", "1001110111", "1100110110", "0111011100", "0000111100", "1100010000", "1011111001", "1101110011", "0000110100",   # 486
        "0111000100", "1000011011"
    ]

    selected_numbers = []
    for _ in range(30):
        selected_group = random.randint(0, 487)
        selected_number = random.randint(0, 9)
        selected_numbers.append(groups[selected_group][selected_number])

    return ''.join(selected_numbers)

def main():
    # Generate two random 30-bit binary numbers
    binary1 = generate_random_binary()
    binary2 = generate_random_binary()

    print("Binary1: ", binary1)
    print("Binary2: ", binary2)

    int1 = bin2dec(binary1)
    int2 = bin2dec(binary2)

    if int1 == int2:
        print("The binary numbers are equal.")
        if binary1[0] == '1' and binary2[0] == '1':
            print("Error: Sum of binary numbers will be too large.")
        else:
            sum = int1 + int2
            result = dec2bin(sum)
            print("Sum of binary numbers:        ", result)
    elif int1 > int2:
        print("Binary1 is greater than Binary2.")
        difference = int1 - int2
        result = dec2bin(difference)
        print("Difference of binary numbers: ", result)
        if binary1[0] == '1' and binary2[0] == '1':
            print("Error: Sum of binary numbers will be too large.")
        else:
            sum = int1 + int2
            result = dec2bin(sum)
            print("Sum of binary numbers:        ", result)
    else:
        print("Binary1 is less than Binary2.")
        difference = int2 - int1
        result = dec2bin(difference)
        print("Difference of binary numbers: ", result)
        if binary1[0] == '1' and binary2[0] == '1':
            print("Error: Sum of binary numbers will be too large.")
        else:
            sum = int2 + int1
            result = dec2bin(sum)
            print("Sum of binary numbers:        ", result)

    or_result = int1 | int2
    and_result = int1 & int2
    xor_result = int1 ^ int2

    print("OR of binary numbers:  ", dec2bin(or_result))
    print("AND of binary numbers: ", dec2bin(and_result))
    print("XOR of binary numbers: ", dec2bin(xor_result))

if __name__ == "__main__":
    main()