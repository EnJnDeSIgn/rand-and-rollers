import random

def bin2dec(binary):
    return int(binary, 2)

def dec2bin(decimal):
    return bin(decimal)[2:].zfill(30)

def generate_random_binary():
    groups = [
        "1000000001", "1100100001", "0101111001", "1111101000", "0000110001", "0010001100", "1000000101", "0101110111", "0101100000",
        "0100011100", "0011000000", "1111101110", "0001001011", "1110011011", "0101101011", "0001010100", "1101101001", "0001110111",
        "0000011110", "1011000101", "1000000011", "1001010110", "1010011110", "0111010001", "1000011010", "0110111110", "0011101110",
        "1011110011", "0110110011", "0011100101", "0101101010", "0001010010", "0010100001", "0000011010", "1100000000", "0110001100",
        "0110111010", "1011011010", "1101110001", "0111110010", "0100010010", "1011011111", "0011111111", "1101011110", "0100011010",
        "1001011111", "0000110011", "0100111011", "1011111010", "1011110000", "1000000111", "0100111101", "0100001101", "0111011111",
        "0010100110", "0100000010", "1100011000", "0111011001", "1101000101", "1000100110", "0011110111", "0000001101", "0010000000",
        "1000000110", "0111101111", "1111000100", "0000001100", "0110001101", "1010000110", "0001000110", "0100000000", "0101011111",
        "0110101011", "0011100110", "0010001000", "1010101110", "0001100110", "0101011000", "0010110001", "0111110110", "1001111111",
        "1000111101", "0011000101", "1111001001", "0011000010", "0011110110", "0111100011", "1111010100", "1100010110", "1000010001",
        "1110110001", "0010000011", "1011110110", "1001110011", "1101011000", "1011011100", "0100100110", "0100011111", "1110010001",
        "0011111011", "0111100001", "0000010010", "1010101011", "0101111000", "1101101010", "0101010010", "0010010001", "0011111010",
        "1111111100", "0100110010", "0101011010", "1111100011", "0111111010", "1011010100", "1111110110", "0100010110", "0100000100",
        "0100101100", "0111001001", "1111010010", "0110001110", "1111111011", "1101000010", "1011100000", "0001101110", "1011110010",
        "1001111011", "1101010000", "0001110110", "1101010101", "0001101100", "0011010011", "1110100101", "0001001100", "0110010000",
        "1101110010", "0000110000", "0111111011", "1010011001", "1101101101", "0110010110", "0000000010", "1000010101", "0010111101",
        "0011001101", "0010101011", "1101000110", "1011010101", "1010000101", "0010111010", "1110001100", "0100110101", "0100001100",
        "0100011110", "0101100001", "0100100001", "1100110011", "1000000000", "0100001111", "1110110101", "0011001100", "0110000000",
        "0001010110", "0001001110", "1010100110", "0101100101", "1100010001", "1001001000", "0000000000", "0001000000", "1000110101",
        "0111111111", "0110100101", "1001011110", "0111111100", "0000000111", "0100010101", "0010011111", "0000100001", "0100010001",
        "0000010110", "0010101001", "1001100110", "1101011111", "0110100000", "0101010100", "0110011001", "0010000101", "0001110010",
        "0110101010", "0100110000", "1100111010", "1010001111", "1111011010", "1110111111", "1101100111", "0110110000", "0110100011",
        "0110011111", "0110111001", "0000010001", "0000000001", "0000000100", "0110111000", "0110011011", "1111110000", "1100101000",   # +4 group next line from 212
        "1001010011", "1110111011", "0101110110", "1100011100", "1000000100", "1100011101", "1110000111", "1001001010", "1001001111",   #216
        "1111100001", "1110011111", "1111101011", "1100101101", "0011110101", "1111011101", "1110100111", "1011101011", "1110000101",   #225
        "1000001010", "1111010000", "0000100010", "0011100001", "1110011110", "0000011011", "0001101000", "1010110011", "1111010101",   #234
        "0011101010", "0001000101", "0010011000", "1111011111", "1111111000", "1010010010", "0100101101", "1111001110", "1110111000",   #243
        "0000100011", "0001100000", "0100001110", "0011101011", "0000101111", "0100110001", "0011100011", "0100101111", "0001011101",   #242
        "0111010100", "1101010111", "1001000011", "0110110010", "1001000001", "1110110100", "1001000101", "0001010101", "1100001010"    #251
    ]

    selected_numbers = []
    for _ in range(30):
        selected_group = random.randint(0, 250)
        selected_number = random.randint(0, 9)
        selected_numbers.append(groups[selected_group][selected_number])

    return ''.join(selected_numbers)

def main():
    # Generate two random 30-bit binary numbers
    binary1 = generate_random_binary()
    binary2 = generate_random_binary()

    print("Binary1: ", binary1)
    print("Binary2: ", binary2)

    int1 = bin2dec(binary1)
    int2 = bin2dec(binary2)

    if int1 == int2:
        print("The binary numbers are equal.")
        if binary1[0] == '1' and binary2[0] == '1':
            print("Error: Sum of binary numbers will be too large.")
        else:
            sum = int1 + int2
            result = dec2bin(sum)
            print("Sum of binary numbers:        ", result)
    elif int1 > int2:
        print("Binary1 is greater than Binary2.")
        difference = int1 - int2
        result = dec2bin(difference)
        print("Difference of binary numbers: ", result)
        if binary1[0] == '1' and binary2[0] == '1':
            print("Error: Sum of binary numbers will be too large.")
        else:
            sum = int1 + int2
            result = dec2bin(sum)
            print("Sum of binary numbers:        ", result)
    else:
        print("Binary1 is less than Binary2.")
        difference = int2 - int1
        result = dec2bin(difference)
        print("Difference of binary numbers: ", result)
        if binary1[0] == '1' and binary2[0] == '1':
            print("Error: Sum of binary numbers will be too large.")
        else:
            sum = int2 + int1
            result = dec2bin(sum)
            print("Sum of binary numbers:        ", result)

    or_result = int1 | int2
    and_result = int1 & int2
    xor_result = int1 ^ int2

    print("OR of binary numbers:  ", dec2bin(or_result))
    print("AND of binary numbers: ", dec2bin(and_result))
    print("XOR of binary numbers: ", dec2bin(xor_result))

if __name__ == "__main__":
    main()